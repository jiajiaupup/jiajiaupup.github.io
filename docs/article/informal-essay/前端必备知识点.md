---
title: 前端必备知识点
date: 2021-9-17
tags:
 - 随笔
 - html
 - javascript
categories: 
 - html
 - javascript
---
# 前端重要知识点汇总

# 基础班知识点

## 01 html

### 1.1 基本标签

| 标签名   | 代码        | 类型   | 属性                                                         | 特点事项                                                     | 使用频率 |
| -------- | :---------- | ------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| 大盒子   | div         | 块级   |                                                              | 没有意义的大盒子<br />                                       | 多       |
| 标题     | h1-h6       | 块级   |                                                              | h1最大、h6最小                                               | 多       |
| 段落     | p           | 块级   |                                                              | 段落标签中不能再放div和h标签                                 | 多       |
| 无需列表 | ul>li       | 块级   |                                                              | ul>li标签必须严格嵌套                                        | 多       |
| 表格     | table>tr>td | 块级   | border       边框                                            | 大量数据需要整齐显示<br />存在合并单元格：<br />跨行 rowspan = ‘2’<br />跨列 colspan = ‘2’ | 少       |
| 小盒子   | span        | 行内   |                                                              | 没有意义的小盒子<br />                                       | 多       |
| 加粗     | strong      | 行内   |                                                              |                                                              | 多       |
| 图片     | img         | 行内   | src       图片路径<br />alt       图片显示不出来时的提示信息<br />title     鼠标悬停图片时的提示信息 | 主要格式png、jpg                                             | 多       |
| 链接     | a           | 行内   | href            链接路径                                     | 链接标签中不能再放链接标签                                   | 多       |
| 音频     | audio       | 行内   | src             音频路径<br />controls    音频控件<br />autoplay   自动播放<br />loop           循环播放 | 主要格式MP3                                                  | 少       |
| 视频     | audio       | 行内   | src             音频路径<br />controls    音频控件<br />autoplay   自动播放<br />loop           循环播放 | 主要格式MP4                                                  | 少       |
| 表单     | input       | 行内块 | type         表单类型<br />=> text            文本输入框<br />=> password 密码输入框<br />=> radio         单选<br />=> checkbox 复选框<br />=> submit      提交<br />=> reset         重置<br />name 表单的名字（方便区分）<br />value 表单的默认值（提交数据）<br />placeholder 占位符（更人性化的提示） | checked  让单选、多选被默认被选中                            | 多       |
|          |             |        |                                                              |                                                              |          |



### 1.2 标签类型

- 块级元素

  > 特性：独占一行，宽度默认100%，可以设置宽高

- 行内元素

  > 特性：一行显示多个，宽度默认由内容撑开，不可以设置宽高

- 行内块元素

  > 特性：具备块级和内联的优势，一行显示多个，宽度默认由内容撑开，可以设置宽高
  >
  > 举例：button、input



### 1.3 路径

- 同级-------img图片和html页面处于同一级文件夹

  ```
  ./图片.jpg
  <img src="./tu.jpg" alt="">
  ```

  

- 下一级-------img图片和html页面不处于同一级文件夹，需要先进入图片文件夹再找到图片

  ```
  ./文件夹/图片.jpg
  <img src="./文件夹/tu.jpg" alt="">
  ```

  

- 上一级-------img图片和html页面不处于同一级文件夹，需要先跳出html页面文件夹再找到图片

  ```
  ../图片.jpg
  <img src="../tu.jpg" alt="">
  ```



##  02 css

### 2.1 常用选择器

| 选择器         | css               | html                                                         | 使用               | 特点                       |
| -------------- | ----------------- | ------------------------------------------------------------ | ------------------ | -------------------------- |
| 标签选择器     | div{}             | <div></div>                                                  | 通过标签名找到元素 | 无差异化                   |
| 类选择器       | .box{}            | <div class="box"></div>                                      | 通过类名找到元素   | 指定元素                   |
| 后代选择器     | .boxA .boxC{}     | <div class="boxA"><br/>    <div class="boxB"><br/>        <div class="boxC"></div><br/>    </div><br/></div> | 选择器组合         | 匹配当前元素的子孙后代元素 |
| 子代选择器     | .boxA>.boxB{}     | <div class="boxA"><br/>    <div class="boxB"></div><br/></div> | 选择器组合         | 匹配当前元素的亲儿子元素   |
| 伪类选择器     | .box:hover{}      | <div class="box"></div>                                      | 鼠标悬停时触发     | 一种状态                   |
| 结构伪类选择器 | li:nth-child(n){} | <ul><br /><li>1</li><br /><li>2</li><br /><li>3</li><br /><li>4</li><br /><li>5</li><br /></ul> | 获取li的第n个元素  | 指定获取某一个             |

<div class="boxA">
    <div class="boxB">
        <div class="boxC"></div>
    </div>
</div>




### 2.2 常用样式



| 样式         | 属性名               | 属性值                                                       | 备注                                                         |
| ------------ | -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 宽度         | width                | 数值+px                                                      |                                                              |
| 高度         | height               | 数值+px                                                      |                                                              |
| 颜色         | color                | 单词、16进制、rgba                                           |                                                              |
| 字体大小     | font-size            | 数值+px                                                      |                                                              |
| 字体粗细     | font-weight          | 400（正常）-700（加粗）                                      |                                                              |
| 字体样式     | font-style           | normal  正常<br />italic       倾斜                          |                                                              |
| 字体类型     | font-family          | "Microsoft YaHei"、微软雅黑                                  |                                                              |
| 字体连写     | font                 | style weight size family                                     | size family为必填项                                          |
| 文本对齐方式 | text-align           | left/center/right                                            | 控制元素内部文字、图片对齐方式                               |
| 文本修饰     | text-decoration      | none 清除                                                    |                                                              |
| 行高         | line-height          | 数值+px                                                      | line-height和height一致控制单行文本垂直居中                  |
| 背景颜色     | background-color     | 单词、16进制、rgba                                           |                                                              |
| 背景图       | background-image     | url(图片路径)                                                |                                                              |
| 背景平铺     | background-repeat    | repeat 重复<br />no-repeat 不重复                            |                                                              |
| 背景位置     | background-posistion | 方位名词<br />left、center、right、top、bottom<br />精确单位<br /><br />x、y轴值 | 精确单位控制方向<br />X和Y轴方向不能混<br />X轴控制左右，正值向右、负值向左<br />Y轴控制上下，正值向上、负值向下<br /> |
| 背景尺寸     | background-size      | 数值+px（X轴  Y轴）<br />cover   <br />contain               | cover 等比例缩放，直到其他两条边都覆盖（缺点：溢出部分被切掉）<br />contain 等比例缩放，直到其他一条边覆盖（缺点：没覆盖位置留白） |
| 背景连写     | background           | color image repeat posistion/size                            | 顺序没有要求<br />背景颜色和图片可以同时存在                 |
| 切换显示模式 | display              | block 块级<br />inline 行内<br />inline-block 行内块<br />none 隐藏元素 | none和block属性可以看成一对反义词，专门处理隐藏和显示的功能  |
| 垂直对齐方式 | vertical-align       | top         顶部对齐<br />middle  中间对齐<br />bottom  底部对齐 | 解决文字、图片、表单元素垂直对不齐问题                       |
| 鼠标样式     | cursor               | pointer  手型                                                |                                                              |
| 圆角         | border-radius        | px、百分比                                                   |                                                              |
| 溢出部分效果 | overflow             | hidden 溢出隐藏<br />scroll    溢出显示滚动条<br />auto     不溢出则正常显示，溢出则显示滚动条 |                                                              |
| 透明度       | opacity              | 0-1                                                          | 0透明<br />0-1之间 半透明<br />1不透明                       |
| 过渡         | transition           | 过渡属性 过渡时间                                            | 牛逼的属性，可以替代很多动态效果                             |
|              |                      |                                                              |                                                              |



### 2.3 盒子模型

盒子模型由内容、内边距、边框、外边距组成。

| 内容   | 属性    | 取值个数                                                     | 单独方向                                                     | 作用                 | 取值           |
| ------ | ------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------- | -------------- |
| 内容   | width   | 1                                                            | 无                                                           | 里面内容             | px             |
| 内边距 | padding | 1个 4个方向<br />2个 左右 上下<br />3个 上 左右 下<br />4个 上右下左 | padding-left<br />padding-right<br />padding-top<br />padding-bottom<br /> | 盒子与文字之间的距离 | px             |
| 边框   | border  | 1                                                            | border-left<br />border-right<br />border-top<br />border-bottom<br /> | 盒子的轮廓           | 粗细 样式 颜色 |
| 外边距 | margin  | 1个 4个方向<br />2个 左右 上下<br />3个 上 左右 下<br />4个 上右下左 | margin-left<br />margin-right<br />margin-top<br />margin-bottom<br /> | 盒子与盒子之间的距离 | px             |
|        |         |                                                              |                                                              |                      |                |

注意事项：

- 盒子模型的组成部分很简单，但是搭配非常灵活！
- 盒子真实大小由内容、内边距、边框共同影响，在开发过程中不太方便。
- 改变盒子模型的计算方式，只由盒子width决定。加入属性 box-sizing : border-box

### 2.4 浮动和清除浮动

浮动作用：让元素一排显示

浮动代码：float：left、right

浮动注意：是兄弟就一起浮动

浮动后注意：清除浮动（清除浮动带来的问题）

如何清除浮动：在浮动元素亲父级身上加入类名 clearfix  。 具体clearfix请复制下面代码

```
// css
li {
	float:left;
}
.clearfix:after {
  visibility: hidden;
  display: block;
  font-size: 0;
  content: " ";
  clear: both;
  height: 0;
}

// html
// 父级清除浮动
<ul class = 'clearfix'>
	<li>儿子们一起浮动</li>
	<li>儿子们一起浮动</li>
	<li>儿子们一起浮动</li>
	<li>儿子们一起浮动</li>
</ul>
```



### 2.5 定位

| 定位模式 | 定位属性           | 相对与谁定位                                                 | 是否脱标（占据位置） | 使用场景                 |
| -------- | ------------------ | ------------------------------------------------------------ | -------------------- | ------------------------ |
| 相对定位 | position: relative | 自身                                                         | 不脱标、占位置       | 打辅助（子绝父相）       |
| 绝对定位 | position: absolute | 有定位父级则以定位父级为标准<br />没有定位父级则以浏览器为标准 | 脱标、不占位置       | 压住其他元素             |
| 固定定位 | position: fixed    | 浏览器为标准                                                 | 脱标、不占位置       | 固定在浏览器的某一个位置 |

子绝父相，最常用的一种定位方式，解释：

子绝：让元素压住别人（完成页面效果）

父相：给子绝元素当爹的（保证子绝元素的定位标准），而且不影响其他页面结构（占据位置、不脱标）





## 03 js基础

介绍：

js基础学的就是ECMAScript，是整个javascript语言的一个基础，所有代码都按这个规范执行



#### 3.1 变量

```js
var myName = '黑马彭于晏';
myName = '黑马吴彦祖'
```

> 备注：myName 是变量名，变量名尽量做见名知意（驼峰命名 myName 或用下划线my_name）

###### 

#### 3.2 数据类型

  - 字符串 （凡事被引号引起来的都是字符串）
  - 数字 （正负数、小数、NaN）
  - 布尔 （真true、假false）
  - undefined
  - null



#### 3.3 数据检测

```
typeof myName
```

> 无法检测对象和数组，所以后面还会有其他用于检测 instanceof



#### 3.4 数据类型的转换

- 任何类型转为字符串类型 

```javascript
var num = 10;
var str = num.toString();
```

  - 任何类型转为数值类型


```javascript
var str = '3.14px'
var num1 = parseInt(str);//3
var num2 = parseFloat(str); //3.14
```

- 任何类型转为布尔类型

```js
var str = 
- ''  空字符串
- 0
- NaN
- undefined
- null
var boolean = Boolean(str);
```

> 5种带有否定意义的变量会转成false，其他都会转为true



#### 3.5 +号的作用

- 拼接

  ```
  var num = 1;
  var str = '2';
  var res = num + str;// 12
  ```

  > 备注：+号两边存在字符串，那么结果就是拼接

- 计算

  ```
  var num1 = 1;
  var num2 = 2;
  var res = num1 + num2;// 3
  ```

  > 备注：+号两边都是数字，那么结果就是计算



#### 3.6 运算符

- 算数运算符

  ```
  加、减、乘、除、取余
  + - * / %
  ```

  > 备注：% 是取余，获取除法后面的余数

- 递增递减运算符

  ```
  i++  i--
  ++i  --i
  ```

  > 备注：对于正常开发 ++i 和i++ 没有任何区别，就把他们当做自加一即可！

- 比较运算符

  ```
  >      大于
  >=     大于等于
  <      小于
  <=     小于等于
  ==     值相等        1 == '1'  结果为 true
  ===    值和类型相等   1 === '1' 结果为 false
  ```

  

- 逻辑运算符

  ```
  &&  并
  举例：上5楼的两个条件：单身并且有钱，同时满足结果才真
  ||  或
  举例：免费乘车的两个条件：小于12岁或大于70岁，其中任意一个为真结果就为真
  !  非
  举例：非男 就是女
  ```

  

- 赋值运算符

  ```
  =
  var num = 1;
  把右边的内容，放到左边的变量中
  --------------------------
  +=、-=、*=、/=
  num = num + 10;
  等价于
  num += 10;
  ```
  
  > 备注：+=的赋值运算符，只是一个简写，并不着急熟练使用，项目中看的懂即可，以后自然用的6



#### 3.7 判断

- 条件判断

```javascript
  if(判断条件){
     满足条件执行
  }
```

> 备注：满足条件执行，不满足不执行

- 二选一

```javascript
  if(判断条件){
     满足条件执行
  }else{
     不满足条件执行
  }
```

> 备注：二选一的过程，总会选一条执行

- 多选一

```javascript
  if(判断条件){
     满足条件执行
  }else if(判断条件){
     满足条件执行         
  }else{
     不满足条件执行
  }
```

> 备注：
>
> 1.多选一的过程，总会选一条执行
>
> 2.此外还有switch case的判断语法，但优先使用if语法



- 三元表达式


```
var flag = 判断条件 ? 满足条件执行 : 不满足条件执行
```

> 备注：if else 的简写形式，默认多一个return功能。



#### 3.8 循环

for基本语法

```javascript
for(初始化变量; 条件表达式; 操作表达式 ){
	//循环体
}
```

```javascript
// 打印10次代码
for(var i = 1; i <= 10; i++){
	console.log('黑马彭于晏来了！');
}
```

>备注：
>
>1.做重复的事情就用for循环
>
>2.如果一个for循环处理不了，才需要用到双重for循环（实战项目中，如果能用一个for解决问题的，千万别用双重for循环！）
>
>3.此外还有 while、do while 的循环语法，但优先使用for语法

跳出循环

- continue

  ```js
  for(var i = 1; i <= 10; i++){
  	console.log('黑马彭于晏来了！');
  	if(i == 5){	
  		continue
  	}
  }
  //遇到continue 跳出当次循环，最终执行 10 次
  ```

  

- break

  ```js
  for(var i = 1; i <= 10; i++){
  	console.log('黑马彭于晏来了！');
  	if(i == 5){
  		break
  	}
  }
  //遇到 break 跳出当前循环，最终执行 5 次
  ```

  



#### 3.9 数组

##### 3.9.1 概念

存储一组有序的数据集合

##### 3.9.2 声明

- 标准

```js
var 数组名 = new Array();
var arr = new Array(); // 创建一个新的空数组
```
- 简写
```js
var 数组名 = [];
var arr = []; // 创建一个新的空数组
var arr = [1,2,'3','4',false,true,[1,2,3]]; // 创建一个新的有数据的数组
```

> 备注：
>
> 1.后者声明方式为简写，完全等价前者
>
> 2.数组中可以存放任何数据



##### 3.9.3 调用

- 写

  ```
  数组[ 索引 ] = 新数据;
  arr[index] = 1;
  ```

  > 备注：index是索引，从0开始数

- 取

  ```
  arr //获取整个数组 []
  arr[index] //获取数组中的某一个
  ```

- 遍历

  ```
  var arr = ['red','green', 'blue'];
  for(var i = 0; i < arr.length; i++){
  	console.log(arr[i]);
  }
  ```

  > 备注：遍历就是循环数组的每一项，把里面的具体数据获取出来



#### 3.10 对象

##### 3.10.1 概念

存储一组无序的数据集合



##### 3.10.2 声明

- 标准

```
var 对象名 = new Obect();
var star = new Obect();// 创建一个新的空对象
star.name = 'pink';// 给对象一个一个的赋值
star.age = 18;
star.sex = '男';
star.sayHi = function(){
	alert('大家好啊~我叫黑马最帅');
}
```

- 简写

```
var 对象名 = {};
var star = {};// 创建一个新的空对象
var star = {
    name : 'pink',
    age : 18,
    sex : '男',
    sayHi : function(){
    	alert('大家好啊~我叫黑马最帅');
    }
}; // 创建一个新的有内容的对象
```

> 备注：
>
> 1.后者声明方式为简写，完全等价前者
>
> 2.对象中可以存放任何数据

- 构造函数

```
function 构造函数名(形参1,形参2,形参3) {
    this.属性名1 = 参数1;
    this.属性名2 = 参数2;
    this.属性名3 = 参数3;
    this.方法名 = 函数体;
}
var obj = new 构造函数名(实参1，实参2，实参3);
```

> 备注：构造函数可以批量创建对象

> 优势：可以把对象中一些公共的属性和方法抽取出来，每次创建后，自带这些属性和方法（省心）



##### 3.10.3 调用

- 点语法

  ```js
  var star = {
      name : 'pink',
      sayHi : function(){
      	alert('大家好啊~');
      }
  };
  star //对象本身
  star.name //pink 使用对象身上的属性
  star.sayHi() // 弹框 大家好啊~ 调用对象身上的方法
  ```

- 中括号法

  ```js
  star //对象本身
  star['name'];// pink 使用对象身上的属性
  star['sayHi'](); // 弹框 大家好啊~ 调用对象身上的方法
  ```

  ```js
  star['name'];// pink
  变化：
  var myname = 'name';
  star[myname] // pink
  ```

  > 备注：注意[]中的变量和字符串的变化，myname变量在使用的时候，会自动被替换为字符串'name',性质和效果一致

- 遍历对象

  ```
  for (变量 in 对象名字) {
  	// 在此执行代码
  }
  
  for (var k in obj) {
      console.log(k); // 这里的 k 是属性名
      console.log(obj[k]); // 这里的 obj[k] 是属性值
  }
  ```

  



#### 3.11 函数

##### 3.11.1 概念

把一个做好的事情包装起来，随时拿出来反复调用



##### 3.11.2 申明

```javascript
function 函数名() {
	//函数体代码
}
```

```javascript
var 函数名 = function (){
	//函数体代码
}
```

> 备注：两者基本等价



##### 3.11.3 调用

```javascript
函数名()
```

> 备注： （）可以调用函数 ，函数不调用不执行



##### 3.11.4 参数

函数的参数分为形参和实参，实参是实际的内容，真实的诉求，而形参是函数内用来接收实参的一个变量

```javascript
function 函数名(形参1,形参2) {// 可以定义任意多的参数，用逗号分隔  var 形参1 = 实参1 ...
	//函数体代码
}
// 带参数的函数调用
函数名(实参1,实参2)
函数名(实参3,实参4)
函数名(实参5,实参6)
```

> 备注：
>
> 1.在函数体内 相当于 var 形参1 = 实参1 ...
>
> 2.实参和形参个数尽量做到一一匹配



##### 3.11.5 arguments

arguments 相当于函数的实参集合

```javascript
function 函数名(形参1, 形参2 , 形参3...) {
	// 函数体
	arguments // 实参集合，是一个伪数组 相当于 var arguments = [形参1, 形参2 , 形参3,...]
}
函数名(实参1, 实参2, 实参3...);
```



##### 3.11.6 return

1. 返回数据

   将函数 return后的内容 返回到函数调用处，方便其他地方使用

   ```
   function 函数名(){
   	...
   	return 需要返回的值；
   }
   console.log(函数名());
   ```

   > 备注：需要返回的值可以是函数运行最终的结果，也可以是任意的内容

   

2. 停止函数

   终止函数后续代码的运行

   ```
   function 函数名(){
   	执行代码1
   	return
   	不执行代码2
   }
   ```

   >备注：执行代码1 ，但不执行代码2

   



#### 3.12 内置对象

##### 3.12.1 常用数学对象

| 属性、方法名          | 功能                                    |
| --------------------- | --------------------------------------- |
| Math.floor()          | 向下取整                                |
| Math.ceil()           | 向上取整                                |
| Math.round()          | 四舍五入版 就近取整 注意 -3.5 结果是 -3 |
| Math.abs()            | 绝对值                                  |
| Math.max()/Math.min() | 求最大和最小值                          |
| Math.random()         | 获取范围在[0,1)内的随机值               |



##### 3.12.2 常用日期对象

使用Date实例化日期对象

- 获取时间对象

```
var now = new Date();
```



- 设置时间对象

```
var future = new Date('2020/6/1'); 
var future = new Date('2020-07-01 12:12:12'); 
```



- 获取对应时间日期 

| 属性、方法名       | 功能     | 特殊情况                        |
| ------------------ | -------- | ------------------------------- |
| date.getFullYear() | 返回年   |                                 |
| data.getMonth()    | 返回月   | 0-11  --- 0代表1月              |
| data.getDate()     | 返回日   |                                 |
| data.getDay()      | 返回星期 | 0-6  --- 0代表周日 --- 6代表周6 |
| data.getHours()    | 返回时   |                                 |
| data.getMinutes()  | 返回分   |                                 |
| data.getSeconds()  | 返回秒   |                                 |

> 备注：date是new Date()来的实例对象



##### 3.12.3 常用数组方法

| 方法名           | 功能                 | 说明                                                    |
| ---------------- | -------------------- | ------------------------------------------------------- |
| push(num）       | 添加数据             | 把num添加至数组的最后                                   |
| join(‘,’)        | 拼接（数组转字符串） | 把数组拼接成一个字符串，中间用  ‘,’ 号连接              |
| indexOf(‘num’)   | 获取索引             | 获取num内容对应的索引，如果不存在返回  -1               |
| slice(start,end) | 截取                 | 从数组的索引start位开始截取，截取至end位(但取不到end位) |



##### 3.12.4 常用字符串方法

| 方法名           | 功能                 | 返回值                                                    |
| ---------------- | -------------------- | --------------------------------------------------------- |
| replace(old,new) | 替换字符串           | 返回新的字符串                                            |
| slice(start,end) | 截取                 | 从字符串的索引start位开始截取，截取至end位(但取不到end位) |
| split('-')       | 切割（字符串转数组） | 返回新的数组                                              |



### 04 jsApi

#### 4.1 获取元素

- 获取单个元素

  ```js
  var el = document.querySelector('选择器')
  ```

  >备注：获取的是单个元素，可直接使用

- 获取多个元素

  ```js
  var els = document.querySelectorAll('选择器')
  ```

  > 备注：获取的是多个元素的集合（伪数组），不能直接使用，需要通过数组方式获取出里面的元素





#### 4.2 操作元素内容

- 获取元素内容  

  ```js
  var html = el.innerHTML
  ```

- 设置或修改元素内容

  ```js
  el.innerHTML = '<h1>标题</h1>';
  ```

  > 备注：innerHTML可以设置页面内容，并且把html文本变成页面结构



#### 4.3 操作元素属性

- 获取元素属性

  ```js
  var attr = el.src
  var attr = el.href
  var attr = el.checked
  ```

  >备注：获取元素属性分为普通属性和表单属性，把元素当作对象使用，所以获取方式一致

- 设置元素属性

  ```js
  el.src = './1.img';
  el.href = './1.html';
  el.checked = true;
  ```

  >type：类型、value：表单值、checked单选复选被选中状态、selected下拉被选中状态、disabled禁用

#### 4.4 操作元素自定义属性

- 获取元素自定义属性

  ```js
  var attr = 对象.getAttribute('属性名');
  var attr = el.getAttribute('data-id');
  ```

  > 备注：html5标准要求在写自定义属性的时候前面加上data-，方便区分普通属性和自定义属性

- 设置元素自定义属性

  ```js
  var attr = 对象.setAttribute('属性名','属性值');
  var attr = el.setAttribute('data-id','myid');
  ```



#### 4.5 操作元素行内样式

- 获取元素行内样式

  ```js
  语法：元素.style.样式属性
  var style = el.style.width
  var style = el.style.backgroundImage
  ```

- 设置元素行内样式

  ```js
  语法：元素.style.样式属性 = '样式属性值'
  el.style.width = '100px'
  el.style.backgroundImage = './1.img'
  ```
  
  > 备注：
  >
  > 1.通过el.style.样式的方法，设置的为行内样式
  >
  > 2.设置的css属性过长，请使用驼峰命名



#### 4.6 操作元素类名

-  获取元素类名

  ```js
  语法：元素.className
  var myclass = el.className;
  ```

- 设置元素类名

  ```js
  语法：元素.style.样式属性 = '样式属性值';
  el.className = 'class1';
  el.className = 'class1 class2';
  ```

  > 备注：
  >
  > 1.class是关键字，所以不能直接使用class来设置类名
  >
  > 2.设置类名的时候，会覆盖之前元素身上的类名



#### 4.7 操作元素节点

- 获取父元素

  ```js
  var el = el.parentNode
  ```

- 获取所有子元素

  ```js
  var els = el.children
  ```

- 获取第1个子元素

  ```js
  var el = el.firstElementChild
  ```

  > 备注：也可以采用el.children[index]对元素进行获取，el.children[0]用于获取第一个子级元素节点

- 获取最后1个子元素

  ```js
  var el = el.lastElementChild
  ```

  >备注：也可以采用el.children[index]对元素进行获取，el.children[children.length-1]用于获取最后一个子级元素节点

- 获取上一个兄弟元素

  ```js
  var el = el.previouElementSibling
  ```

- 获取下一个兄弟元素

  ```js
  var el = el.nextElementSibling
  ```

- 创建元素

  ```js
  var divNode = document.createElement('div');
  ```

- 添加节点(后面)

  ```js
  el.appendChild(divNode)
  ```

  > 备注：把divNode这个元素放在el元素内部的最后

- 添加节点(指定位置)

  ```js
  el.insertBefore(divNode,targetNode)
  ```

  > 备注：把divNode这个元素放在el元素内部并且是targetNode元素的前面

- 删除元素

  ```js
  el.removeChild(child);
  ```

  > 备注：必须要先找到被删除元素的父级，再在父级元素内删掉里面的子元素

- 克隆元素

  ```js
  var cloneNode = el.cloneNode(Boolean);
  ```

  >备注：
  >
  >1.如果Boolean为false（默认）,则为浅拷贝，只拷贝最外层的标签元素
  >
  >2.如果Boolean为true,则为深拷贝，拷贝元素并且拷贝元素内的所有后代元素



#### 4.8 主要事件

| 鼠标事件类型 | 单词                     | 备注                      |
| ------------ | ------------------------ | ------------------------- |
| 鼠标点击     | onclick                  |                           |
| 鼠标移入     | onmouseover/onmouseenter | onmouseenter 没有冒泡问题 |
| 鼠标移动     | onmousemove              |                           |
| 鼠标移出     | onmouseout/onmouseleave  | onmouseleave 没有冒泡问题 |
| 键盘按下     | onkeydown                | 识别功能键                |
| 键盘按下     | onkeypress               | 识别大小写                |
| 键盘弹起     | onkeyup                  |                           |
| 获取焦点     | onfocus                  |                           |
| 失去焦点     | onblur                   |                           |
| 表单内容改变 | onchange                 |                           |
| 页面加载     | onload                   |                           |
| 页面尺寸改变 | onresize                 |                           |
| 页面滚动     | onscroll                 |                           |

#### 4.9 事件监听

##### 4.9.1 传统绑定事件

语法：

```js
事件源.事件类型 = function(){}	
```

举例：

```js
var btn = document.querySelector('button');
btn.onclick = function() {
	alert('hi');
}
```



##### 4.9.2 事件监听绑定事件

语法：

```js
事件源.addEventListener('事件类型',funtion(){})
```

举例：

```js
var btn = document.querySelector('button');
btn.addEventListener('click', function() {
	alert('hi');
})
```



##### 4.9.3 传统解绑事件

语法：

```js
事件源.事件类型 = null
```

举例：

```js
var btn = document.querySelector('button');
btn.onclick = null
```

##### 4.9.4 事件监听解绑事件

语法：

```js
事件源.removeEventListener('click',同一个回调函数)
```

举例：

```js
var btn = document.querySelector('button');
var fn = function(){
	alert('hi');
}
btn.addEventListener('click', fn)
btn.removeEventListener('click', fn)
```

>备注：
>
>1.用事件监听方式绑定和解绑的函数必须是同一个地址的函数
>
>2.传统事件的绑定针对于同一个元素的同一种类型事件绑定只能有一次，如果多次绑定会被覆盖。所有建议采用事件监听。



#### 4.10 事件流

##### 4.10.1 主要阶段

1. 捕获阶段   从大变小的触发
2. 当前目标阶段
3. 冒泡阶段  从小到大的触发

> 备注1：
>
> 1.执行事件流的时候，不可能同时触发捕获阶段和冒泡阶段，只会二取其一
>
> 2.事件流是默认存在的，只是父子级绑定事件后会把事件流的过程体现出来



> 备注2：需要同时具备2个条件才会体现出问题
>
> 1.绑定元素是包含关系的（祖父辈元素和子孙后代元素）而不是兄弟之类的关系
>
> 2.绑定的是同一个类型的事件



##### 4.10.2 事件流的优势

事件委托，减少dom绑定次数

举例：

```js
<ul>
    <li>知否知否，点我应有弹框在手！</li>
    <li>知否知否，点我应有弹框在手！</li>
    <li>知否知否，点我应有弹框在手！</li>
    <li>知否知否，点我应有弹框在手！</li>
    <li>知否知否，点我应有弹框在手！</li>
</ul>
<script>
// 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点
var ul = document.querySelector('ul');
ul.addEventListener('click', function(e) {
    // e.target 这个可以得到我们点击的对象
    e.target.style.backgroundColor = 'pink';
})
</script>
```



##### 4.10.3 事件流的缺点

造成不必要的事件触发



#### 4.11 事件对象

事件对象是浏览器默认给每一个事件提供

事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象。

```js
function(e){
	e   这个e就是事件对象，浏览器默认就提供了的
}
```



- 阻止默认事件

  ```js
  e.preventDefault()
  ```

- 阻止冒泡事件

  ```js
  e.stopPropagation()
  ```

  >备注：阻止冒泡事件，只能防止这一层冒泡，所以往往被冒泡的所有函数都写一个阻止冒泡的事件

- 获取鼠标坐标

  ```js
  client 鼠标在可视区的x和y坐标
  e.clientX
  e.clientY
  
  page 鼠标在页面文档的x和y坐标
  e.pageX
  e.pageY
  
  screen 鼠标在电脑屏幕的x和y坐标
  e.screenX
  e.screenY
  ```

- 获取用户输入的哪个键

  ```js
  e.keyCode //获取到的是按键对应的Ascll值
  ```
  
  举例：我们可以通过e.keyCode进行对应键盘事件的绑定列子如下
  
  ```js
   document.addEventListener('keydown', function(e) {
       if(e.keyCode==13){
       	console.log('我按下了enter键')
       }
   })
  ```
  
  

#### 4.12 定时器

##### 4.12.1 炸弹型定时器

介绍：等待一定时间执行里面的回调函数

语法：

```js
//设置  
var timer = setTimeout(回调函数, 时间);
//清除  
clearTimeout(timer);
```

使用方法：

1. ```js
   setTimeout(function() {
       console.log('炸弹型定时器只触发一次');
   }, 1000);
   ```

2. ```js
   function fn(){
   	console.log('炸弹型定时器只触发一次');
   }
   setTimeout(fn, 1000);
   ```

3. ```js
   function fn(num){
   	console.log('炸弹型定时器只触发一次,并且可以传参哦'+num);
   }
   setTimeout('fn(100)', 1000);
   ```

   

##### 4.12.2 间歇型定时器

介绍：每隔一定时间就执行里面的回调函数

语法：

```js
设置  var timer = setInterval(回调函数, 时间);
清除  clearInterval(timer);
```

使用方法：

1. ```js
   setInterval(function() {
       console.log('间歇性定时器每隔一段时间触发一次');
   }, 1000);
   ```

2. ```js
   function fn(){
   	console.log('炸弹型定时器只触发一次');
   }
   setInterval(fn, 1000);
   ```

3. ```js
   function fn(num){
   	console.log('炸弹型定时器只触发一次,并且可以传参哦'+num);
   }
   setInterval('fn(100)', 1000);
   ```

   

#### 4.13 BOM

##### 4.13.1 location对象

介绍：获取或设置浏览器url

主要方法：

- 获取浏览器url地址 

  ```js
  var href = location.href
  ```

- 获取浏览器url的返回参数

  ```js
  var search = location.search
  ```

  

##### 4.13.2 navigator对象

介绍：获取浏览器的信息

主要方法：

- 获取浏览器的客户机版本

  ```js
  navigator.userAgent
  ```

  

##### 4.13.3 history对象

介绍：获取浏览器历史

主要方法：

- 控制浏览器返回按钮

  ```js
  history.back()
  ```

- 控制浏览器前进按钮

  ```js
  history.forward()
  ```

- 跳转到浏览历史列表的任意位置

  ```js
  history.go(); 
  ```

   位置标志： 当前页为第0个，前一个页面第1个，后一个页面-1个

#### 4.14 同步异步

​	异步代码：定时器、触发事件、ajax

​	同步代码：剩下的都是同步代码

​	概念：优先执行所有的同步代码，再执行异步代码



#### 4.15 网页的三大系列

##### offset 系列


```js
获取当前元素距离定位父级的距离
var left = el.offsetLeft
var top = el.offsetTop
```

##### client  系列


```js
获取当前元素自身的宽度和高度（内容+内边框）
var width = el.clientWdith
var height = el.clientHeight
```

##### scroll  系列


```js
获取元素被卷去的距离（部分）
var top = el.scrollTop;
获取浏览器被卷去的距离
var top = window.pageYOffset;
```



### 05 jQuery

#### 5.1入口函数

```
$(function () {   
    ...  // 此处是页面 DOM 加载完成的入口
})
```



#### 5.2 获取元素

##### 语法

```js
var jq元素集合 = $('选择器');
```

##### 举例

```
var dom = $('div');   //通过标签选择
var dom = $('.class');//通过类名选择
var dom = $('#id');	  //通过id选择
var dom = $('ul li'); //通过后代选择
```



#### 5.3 获取元素（筛选方法）

- 获取父级

  ```
  var el = $(dom).parent()
  ```

- 获取祖先中的某一个元素

  ```
  var el = $(dom).parents('选择器')
  ```

- 获取子级

  ```
  var el = $(dom).children()
  ```

- 获取子孙后代中的某一个

  ```
  var el = $(dom).find('选择器')
  ```

- 获取上一个兄弟

  ```
  var el = $(dom).prev()	
  ```

- 获取之前所有兄弟

  ```
  var el = $(dom).prevAll()
  ```

- 获取下一个兄弟

  ```
  var el = $(dom).next()
  ```

- 获取之后所有兄弟

  ```
  var el = $(dom).nextAll()
  ```

- 获取所有兄弟

  ```
  var el = $(dom).siblings()
  ```

- 获取集合中第N个

  ```
  $("dom").eq(N)
  ```

  

#### 5.4 操作样式

##### 5.4.1 操作行内样式

###### 5.4.1.1 获取单个行内样式

```
var width = $(dom).css('width');
```

###### 5.4.1.2 设置单个行内样式

```
$(dom).css('width','300px');
```

##### 5.4.2 操作行内样式

###### 5.4.2.1 设置多个行内样式

```
$(dom).css({
	'width':'300px',
	'height':'300px',
	'backgroundColor':'red'
});
```



#### 5.5 操作类名

##### 5.5.1 新增类名

```
$(dom).addClass('myclass');
$(dom).addClass('myclass1 myclass2');
```

> 备注：不会覆盖之前的class，只做新增

##### 5.5.1 删除类名

```
$(dom).removeClass('myclass');
```

##### 5.5.1 切换类名

```
$(dom).toggleClass('myclass');
```



#### 5.6 操作页面

##### 5.6.1 获取标签内容

```
var html = $(dom).html();
```

##### 5.6.2 设置标签内容

```
$(dom).html('<p>标签</p>');
```

##### 5.6.3 获取表单内容

```
var html = $(dom).val();
```

##### 5.6.4 设置表单内容

```
$(dom).val('内容');
```



#### 5.6 操作元素属性

##### 5.6.1 获取固有属性

```
var prop = $(dom).prop('type');
```

##### 5.6.2 设置固有属性

```
$(dom).prop(‘type’,'text');
```

##### 5.6.3 获取自定义属性

```
var prop = $(dom).attr('data-index');
```

##### 5.6.4 设置自定义属性

```
$(dom).attr('data-index','999');
```



#### 5.7 页面效果

##### 5.7.1 显示元素

```
$(dom).show();
```

##### 5.7.2 隐藏元素

```
$(dom).hide();
```



#### 5.8 操作元素

##### 5.8.1 创建

```
var html = $('<h1>新标签</h1>');
```

##### 5.8.2 添加

- 元素内部后面添加

  ```
  $(dom).append(html);
  ```

- 元素内部前面添加

  ```
  $(dom).prepend(html);
  ```

##### 5.8.3 删除

```
$(dom).remove();
```

> 备注：找到dom元素，一起删除掉



#### 5.9 遍历

```
$(dom).each(function(i,el){
	i  索引
	el 元素
});
```

> 备注：类似于for循环，找到所有dom元素，依次循环



#### 5.10 元素尺寸、位置、卷去距离

##### 5.10.1 获取元素宽度

```
$(dom).width();
```

##### 5.10.2 设置元素宽度

```
$(dom).width(300);
```

##### 5.10.3 获取元素高度

```
$(dom).height();
```

##### 5.10.4 设置元素高度

```
$(dom).height(300);
```

##### 5.10.5 获取元素到文档顶部的位置

```
$(dom).offset().top
```

##### 5.10.6 设置元素到文档顶部的位置

```
$(dom).offset({
	top:300
})
```

##### 5.10.7 获取元素到文档左侧的位置

```
$(dom).offset().left
```

##### 5.10.8 设置元素到文档左侧的位置

```
$(dom).offset({
	left:300
})
```

##### 5.10.9 获取元素被卷去的距离（顶部）

```
$(dom).scrollTop()
```

##### 5.10.10 设置元素被卷去的距离（顶部）

```
$(dom).scrollTop(300)
```



#### 5.11 绑定事件

##### 5.11.1 普通事件绑定

```
$(dom).click(function(){})
$(dom).mouseenter(function(){})
$(dom).focus(function(){})
```



##### 5.11.2 on方法绑定事件

```
$(dom).on('click',function(){})
$(dom).on('mouseenter',function(){})
$(dom).on('mouseenter mouseleave click',function(){})
```

> 备注：给dom元素绑定一个click 事件



##### 5.11.3 on方法给动态添加的元素绑定事件

```
$(dom).on('click','.mybox',function(){})
```

> 备注：给dom元素下面，类名叫mybox的元素绑定点击事件 （mybox这个元素可以是通过js动态添加进页面的内容）





### 06 js高级

#### 6.1 类

##### 概念

泛指一种类型，对象特指某一个东西

类和构造函数功能一样，类的本质就是构造函数，但比构造函数好用（继承），是构造函数的语法糖，都可以用来批量创建对象。

##### 使用

举例：

```js
class Father {
    constructor(name) {
        // 类的属性
        this.name = name;
        // this.car()
    }
    car() {
        // 类的方法
        console.log(this.name + '要开车')
    }
}
var y = new Father('yj')
var yb = new Father('yjbaba')
y.car()   //yj要开车
yb.car()   //yjbaba要开车
```



#### 6.2 继承

##### 概念

自己没有的方法和属性，可以使用别人的

##### 使用

举例：

```js
class Father {
    constructor(name) {
        // 类的属性
        this.name = name;
        // this.car  // 调用方法
    }
    car() {
        // 类的方法
        console.log(this.name + '要开车')
    }
}
class Son extends Father {
    constructor(name) {
        super(name)
        // this.study() // 调用方法
    }
    study() {
        console.log(this.name + '要学习')
    }
}
var s = new Son('yj')
s.study()   //yj要学习
s.car()     //yj要开车
```

> 备注：
>
> 1.继承的好处：自己没有的可以找别人、爸爸要，爸爸有，就可以直接用，依次类推
>
> 2.super() 相当于调用了父类，而且super()必须放到this的前面，不然会报错
>
> 3.构造函数也能实现属性和方法的继承，但是麻烦很多，所以优先使用类



#### 6.3 原型

##### 概念

1. 原型也叫原型对象
2. 每一个构造函数都默认存在一个原型(实例对象也可以访问到原型)
3. 原型可以共享方法，让代码性能更佳

##### 使用-构造函数访问原型

构造函数.prototype 可以访问到原型对象

```js
// 普通写法：
function Star(){
    this.run = function(){}
}
// 优化写法：
Star.prototype.run = function(){}
```

> 区别：
>
> 1.普通写法：每个通过new Star() 创建实例对象后都有一个独立的run函数
>
> 2.优化写法：所有通过new Star() 创建的实例对象都共享同一个run函数

> 注意：使用类的话，无论什么写法都等同于优化后的写法

##### 使用-实例对象访问原型

`实例对象.__proto__` 也可以访问到原型

```js
function Star(){
    this.run = function(){}
}
var yj = new Star()
yj.__proto__ === Star.prototype //true
```

> 注意：`__proto__` 是浏览器提供的，非标准的



#### 6.4 constructor

##### 概念

constructor就是类或者构造函数的构造器

##### 作用

constructor能够让我们知道当前的实例对象，到底指向谁，谁是创造者



#### 6.5 构造函数三角关系

构造函数--------`.prototype`--------------原型对象

​		  `new`                             `__proto__`

​                             实例对象







#### 6.6 原形链

##### 概念

原形链其实就是实例对象找爸爸的过程，每一个实例对象在调用方法的时候，优先自身，如果自身没有就都会通过`__proto__`去找到原型对象身上的方法。而原型对象也有自己的原型对象（原型对象又是其他构造函数的实例），这样一来，会不断的顺着`__proto__`向上访问，直到null为止，这个找方法的过程就是原形链

##### 使用

实现继承后，就能调用祖辈的方法和属性

##### 作用

1. 增加实例对象的方法
2. 减少重复代码的开发，提高效率

> 注意：原形链的查找规则，就近原则，先看自己，再看原形，再顺着原形链继续向上找





#### 6.7 es5新增循环方法



##### forEach

可以遍历数组、类数组(伪数组)

```js
arr.forEach(function (value, index, array) {
  console.log("每个数组元素" + value);
  console.log("每个数组元素的索引号" + index);
  console.log("数组本身" + array);
});
```



##### filter

数组方法，遍历数组（过滤数组），去除不需要的项，并且返回新数组

```js
var newArr = arr.filter(function (value, index, array) {
  console.log("每个数组元素" + value);
  console.log("每个数组元素的索引号" + index);
  console.log("数组本身" + array);
  return value % 2 === 0;//满足条件的返回
});
```



##### map

数组方法，遍历数组（加工数组），可以给数组的每一项进行加工，并且返回新数组

```js
var newArr = arr.map(function (value, index, array) {
  console.log("每个数组元素" + value);
  console.log("每个数组元素的索引号" + index);
  console.log("数组本身" + array);
  return value+'yj为你打call！！！';//加工每一项
});
```



##### some

数组方法，遍历数组（判断是否存在符合条件的项），并且返回是否成功的状态

```js
var flag = arr.some(function (value, index, array) {
  console.log("每个数组元素" + value);
  console.log("每个数组元素的索引号" + index);
  console.log("数组本身" + array);
  return value < 3;
});
```



##### every

数组方法，遍历数组（判断每一项都是否存在符合条件），并且返回是否成功的状态

```js
var flag = arr.every(function (value, index, array) {
  console.log("每个数组元素" + value);
  console.log("每个数组元素的索引号" + index);
  console.log("数组本身" + array);
  return value < 3;
});
```



#### 6.8 call、apply、bind

##### 概念

1. 都可以实现借调（自己没有借别人的方法来用）改变this的指向


##### call

```
别人的方法.call(调用者,参数 1,参数 2,参数 3,...);
Array.push.call(obj,1,2,3);
```

##### apply

```
别人的方法.apply(调用者,[参数 1,参数 2,参数 3,...]);
Math.min.apply(Math, arr);
```

##### bind

```
别人的方法.bind(调用者,参数 1,参数 2,参数 3,...);
var f = Array.push.bind(o, 1, 2);
f();
```

> 注意：
>
> call、bind的参数都是一个个的、apply的参数是一个数组。
>
> bind会借调别人的方法，并且返回一个属于自己的方法，随时自己调用

#### 6.8 闭包

##### 概念

一个作用域可以访问另一个作用域中变量

##### 使用

```js
function fn() {
  var num = 10;
  return function () {
    console.log(num);
  };
}
var f = fn();
f();
f();
f();
```



##### 优势

延长了变量的作用范围

随时提供私有数据和私有方法（别人操作不了）

##### 缺点

大量的闭包导致内存泄漏





#### 6.9 正则表达式

##### 概念

专门用于匹配的一种语言

##### 使用

```js
var reg = /123/;
var flag = reg.test(str);//如果str字符串中包含reg正则的内容则为true，不包含内容则为false
```

> 注意：不是特别熟的情况都可以直接百度获取正则，我们只需要知道如何调用  test



#### 6.10 let、const

##### 概念

新的声明变量的方式

##### 使用

```js
let num = 1;
let obj = {name:'yj'};
const str = 'yj';
const arr = ['1','2','3','4'];
```

> 注意：一般情况下都可以直接替换var使用

##### 优势

严谨：必须先声明后使用

作用域：块级作用域

> 注意：const是常量 （地址不能变化）

#### 6.11 解构赋值

##### 概念

把变量从大量的数据中解放出来，单独调用

##### 使用：解构对象

```js
let obj = {myclass:'hm',myname:'yj',myage:18,mysex:0,myheight:199,mymoney:9.9}
let {myname,myage} = obj
```

> 注意：变量myname,myage就被释放出来，可以单独使用，不需要再obj.myname  obj.myage

##### 使用：解构数组

```js
let arr = ['高大英俊','日理万机','一日千里','深不可测'];
let [str1,str2] = arr;
```

> 注意：变量 str1,str2 对应的‘高大英俊’，‘日理万机’就被释放出来，可以单独使用，不需要再arr[0]  arr[1]



#### 6.12 箭头函数

##### 概念

简化代码、箭头函数没有this

##### 使用

```js
let fn = ()=>{}
// () 如果只有一个参数的时候可以省略
// {} 返回值只有一句话的时候可以省略 并且带有return效果

// 举例：1
var arr = [11, 312, 3, 14, 235, 2, 52];
arr.foreach(function (v) {
  console.log(v + 5);
});
// 简化:
arr.foreach(v=>console.log(v+5));

// 举例：2
arr.filter(function (v, i) {
  return arr.indexOf(v) === i;
});
// 简化:
arr.filter((v,i) =>{arr.indexOf(v) === i);
```



#### 6.13 剩余参数

##### 概念

获取剩下所有的参数，形成一个真数组

##### 使用

```js
const sum = (...args) => {
	args 等价于 [10,20,30,40]
};
sum(10, 20, 30, 40)

const sum2 = (num1,...args) => {
	args 等价于 [20,30,40]
};
sum2(10, 20, 30, 40)
```



#### 6.14 拓展运算符

##### 概念

把一个数组，拆分为 以逗号隔开的序列

##### 使用

```js
let ary = ["a", "b", "c"];
// ...ary  等价于 "a", "b", "c"
```



#### 6.15 模板字符串

##### 概念

避免了字符串之间+号的拼接问题以及不需要再担心单引双引的问题

##### 使用

反引号把内容括起来，里面的可以放变量和表达式用${}表示

```js
let name = '吴彦祖';
let age = 17;
let fn = ()=>'我唱歌贼溜'
let str = `我是叫黑马${name}，今年${age+1}岁，${fn()},请访问我的个人博客"www.baidu.com"`;
// str等价于 '我是叫黑马吴彦祖，今年18岁，我唱歌贼溜,请访问我的个人博客"www.baidu.com"';
```



### 07 ajax

#### 7.1 ajax的基本概念

##### 概念

实现网页与服务器之间数据交互的一种技术

有了ajax，网页就具备了灵魂，让网页内容千变万化（每次打开淘宝首页，都显示不一样的商品）

##### 网络请求-步骤

1. 客户端对服务器发起请求
2. 服务器进行处理
3. 服务器响应数据给客户端

##### 网络请求-同源策略

**同源**指的是两个 URL 的协议、域名、端口一致，反之，则是**跨域**



#### 7.2 原生ajax

##### 概念

ajax是js原生技术，利用了`XMLHttpRequest`对象实现功能，原生使用起来比较麻烦，建议使用axios或jQuery的ajax

##### 使用

举例：

- get 请求

  ```js
  // 1. 创建 XHR 对象
  var xhr = new XMLHttpRequest()
  // 2. 调用 open 函数
  xhr.open('GET', 'http://www.liulongbin.top:3006/api/getbooks?id=1')
  // 3. 调用 send 函数
  xhr.send()
  // 4. 监听 onreadystatechange 事件
  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4 && xhr.status === 200) {
       // 获取服务器响应的数据
       console.log(xhr.responseText)
     }
  }
  ```

- post 请求

  ```js
  // 1. 创建 XHR 对象
  var xhr = new XMLHttpRequest()
  // 2. 调用 open 函数
  xhr.open('POST', 'http://www.liulongbin.top:3006/api/addbook')
  // 3. 设置 Content-Type 属性（固定写法）
  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
  // 4. 调用 send 函数
  xhr.send('bookname=水浒传&author=施耐庵&publisher=上海图书出版社')
  // 5. 监听事件
  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4 && xhr.status === 200) {
      console.log(xhr.responseText)
    }
  }
  ```



#### 7.3 jQuery的ajax

##### 概念

jQuery是js的库，封装了各种js的函数，也包括封装了ajax的方法

##### 使用 

- get 请求

  ```js
  $.get('http://www.liulongbin.top:3006/api/getbooks',{id:1},function(res){
     	console.log(res)
  })
  ```

- post 请求

  ```js
  $.post('http://www.liulongbin.top:3006/api/addbook',{bookname:'水浒传',author:'施耐庵',publisher:'上海图书出版社'},function(res){
     	console.log(res)
  })
  ```

- 任意请求

  ```js
  $.ajax({
      type:'get',
      url:'http://www.liulongbin.top:3006/api/addbook',
      data:{id:1},
      success(res){
          console.log(res)
      }
  })
  ```

  

- 请求和响应拦截器

  - 添加请求拦截器

    ```js
    $(document).ajaxStart(function() {
        $('#loading').show()
    })
    ```

  

  - 添加响应拦截器

    ```js
    $(document).ajaxStop(function() {
        $('#loading').hide()
    })
    ```

    

#### 7.4 axios的ajax

##### 概念

专门为ajax网络请求而生的库，是基于promise技术的，可以用于node和浏览器端

##### 使用 

- get 请求格式

  ```js
  axios.get('url', { params: { /*参数*/ } }).then(callback)
  ```

- get 请求示例

  ```js
  // 请求的 URL 地址
  var url = 'http://www.liulongbin.top:3006/api/get'
  // 请求的参数对象
  var paramsObj = { name: 'zs', age: 20 }
  // 调用 axios.get() 发起 GET 请求
  axios.get(url, { params: paramsObj }).then(function(res) {
       // res.data 是服务器返回的数据
       var result = res.data
       console.log(res)
  })
  ```

- post 请求格式

  ```js
  axios.post('url', { /*参数*/ }).then(callback)
  ```

- post 请求示例

  ```js
  // 请求的 URL 地址
  var url = 'http://www.liulongbin.top:3006/api/post'
  // 要提交到服务器的数据
  var dataObj = { location: '北京', address: '顺义' }
  // 调用 axios.post() 发起 POST 请求
  axios.post(url, dataObj).then(function(res) {
       // res.data 是服务器返回的数据
       var result = res.data
       console.log(result)
  })
  ```

- 任意请求格式

  ```js
  axios({
   method: '请求类型',
   url: '请求的URL地址',
   data: { /* POST数据 */ },
   params: { /* GET参数 */ }
  }).then(callback)
  ```

- 任意请求示例

  - get请求

    ```js
    axios({
      method: 'get',
      url: 'http://www.liulongbin.top:3006/api/addbook',
      params: {
        id: 1
      },
    })
    .then(function (response) {
        // 处理成功情况
        console.log(response);
    })
    .catch(function (error) {
        // 处理错误情况
        console.log(error);
    });
    ```
    
    
    
- post 请求
  
  ```js
    document.querySelector('#btn4').addEventListener('click', function () {
    axios({
        method: 'POST',
        url: 'http://www.liulongbin.top:3006/api/post',
        data: {
          name: '娃哈哈',
          age: 18,
          gender: '女'
        }
      }).then(function (res) {
        console.log(res.data)
      })
    })
    ```
  
    
  
- 请求和响应拦截器

  - 添加请求拦截器

    ```js
    axios.interceptors.request.use(function (config) {
        // 在发送请求之前做些什么
        return config;
    }, function (error) {
        // 对请求错误做些什么
        return Promise.reject(error);
    });
    ```

  

  - 添加响应拦截器

    ```js
    axios.interceptors.response.use(function (response) {
        // 2xx 范围内的状态码都会触发该函数。
        // 对响应数据做点什么
        return response;
    }, function (error) {
        // 超出 2xx 范围的状态码都会触发该函数。
        // 对响应错误做点什么
        return Promise.reject(error);
    });	
    ```

    

#### 7.4 请求状态

##### 概念

每当发起网络请求，都会有一个最终状态，比如请求后，请求成功或请求失败等，每一种结果都由一种数字表示，看到数字就基本知道请求的结果

##### 示例

| 分类 | 描述                                             |
| ---- | ------------------------------------------------ |
| 1**  | 信息，服务器接收请求需要后续继续操作（很少遇到） |
| 2**  | 成功                                             |
| 3**  | 重定向（前端继续请求）                           |
| 4**  | 客户端错误（前端的代码有问题）                   |
| 5**  | 服务器错误（后端的代码有问题）                   |

#####  

#### 7.5 请求、响应的数据

##### 概念

网络数据不能直接通过对象、数组传输，一般主流都是通过json格式传输（字符串）

##### 使用 

- 序列化，对象转为`json`

  ```js
  let str = JSON.stringify(obj)
  ```

- 反序列化，`json`转为对象

  ```js
  let obj = JSON.parse(str)
  ```

  

### 08 Node.Js(了解)

#### 8.1 node 概念

##### 概念

浏览器是JavaScript的前端运行环境

NodeJs是JavaScript的后端运行环境



#### 8.2 node 内置模块

##### 概念

NodeJs提供了一些自带模块，也叫内置模块

##### 模块

- fs模块-**专门处理文件的模块**

  1. 引入

     ```js
     const fs = require('fs');
     ```

  2. 读取文件

     ```js
     fs.readFile(path[,options],callback)
     ```

  3. 写入文件

     ```js
     fs.writeFile(path,data[,options],callback)
     ```

- path模块-**专门处理路径的模块**

  1. 引入

     ```js
     const path = require('path');
     ```

  2. 拼接路径

     ```js
     const pathStr = path.join([...paths])
     ```

  3. 获取文件名

     ```js
     const pathStr = path.basename(path[,ext])
     ```

  4. 获取拓展名

     ```js
     const pathStr = path.extname(path)
     ```

- http模块-**快速搭建服务器的模块**

  1. 引入

     ```js
      const http = require('http');
     ```

  2. 创建web服务器
  
       ```js
      const server = http.createServer()
      ```
      
  3. 监听网络请求
  
       ```js
       server.on('request',(req,res)=>{
       	req 请求相关的对象
           req.url		请求地址
           req.method	请求类型
           res 响应相关的对象
           res.setHeader('Content-Type','text/html;charset=utf-8')
       	res.send(str) 响应方法
       })
       ```
  
  4. 启动web服务器
  
       ```js
       server.listen(80,()=>{
       	console.log(‘服务器已经启动,地址为http://127.0.0.1’)
       })
       ```



#### 8.3 node 包

##### 概念

NodeJS 中存在

- 内置模块（http、fs、path等，上一个知识点的内容）
- 自定义模块（自己定义的包、js文件）
- 第三方模块（别人写好的包）

##### 使用

1. 导入

   ```js
   const fs = require('fs')
   ```

2. 导出

   ```js
   module.exports = {
       a:1,
       b:2
   }
   ```

   

#### 8.4 node npm

##### 概念

内置模块由NodeJS自带、自定义模块由自己写JS、第三方模块由别人写，但是别人写好的包如何下载呢，必须通过npm工具

npm 是包管理工具（node自带工具）

package.json 是下载包的记录/清单

node_modules 是下载包安装目录

##### 使用

1. 初始化

   ```js
   // 默认所有包的配置，会自动生成 package.json
   npm init -y
   ```

   

2. 下载包

   ```js
   // 下载一个包(下载至上线环境（开发和上线都需要使用）--Dependencies)
   npm install 包名
   // 下载多个包
   npm install 包名1 包名2
   // 下载指定版本的包
   npm install 包名@2.2.2
   // 下载一个包(下载至开发环境（只有开发阶段才会使用）--devDependencies)
   npm install -D 包名
   // 下载至全局
   npm install 包名 -g
   // 下载一个包缩写
   npm i 包名
   ```

   

3. 卸载包

   ```js
   // 卸载一个包
   npm uninstall 包名
   // 卸载多个包
   npm uninstall 包名1 包名2
   // 卸载一个包缩写
   npm uni 包名
   ```

   

#### 8.5 node express

##### 概念

express 是基于`NodeJS`的第三方包

##### 作用

express 可以简单快读的搭建起一个web的开发服务器

##### 使用

1. 下载

   ```js
   npm i express
   ```

2. 引入

   ```js
   const express = require('express');
   ```

3. 创建web服务器

   ```js
   const app = express();
   ```

4. 监听网络请求

   ```js
   app.get('/url',(req,res)=>{
   	req.url		// 获取请求地址
   	req.methods	// 获取请求类型
   	req.params	// 获取请求参数（动态参数方式）
   	req.query	// 获取请求参数（查询字符串方式）
   	req.body	// 获取请求参数（post请求体方式、需要配置解析中间件）
   	res.send(str)// 返回响应数据
   })
   app.post('/url',(req,res)=>{
   	// 同上
   })
   ```

5. 启动web服务器

   ```js
   app.listen(80,()=>{
   	console.log(‘服务器已经启动,地址为 http://127.0.0.1’)
   })
   ```

6. 提供静态服务器

   ```js
   app.use('/public',express.static('public')
   ```

7. 编写路由规则

   ```js
   // node中路由的作用就是请求路径和处理函数之间的关系
   // user.js
   const router = express.Router()
   router.get('/user/list',(req,res)=>{
   	// 如果有用户使用 get 方式访问 http://127.0.0.1/user/list 就会触发这个函数，返回 get 字符串
   	res.send('get')
   })
   router.post('/user/list',(req,res)=>{
   	// 如果有用户使用 post 方式访问 http://127.0.0.1/user/list 就会触发这个函数，返回 post 字符串
   	res.send('post')
   })
   module.exports = router
   
   // app.js
   const userRouter = require('./router/user.js')
   app.use('/api',userRouter)
   ```

8. 编写中间件

   ```js
   // 中间件是专门处理业务逻辑的中间环节，可以有任意数量
   app.use('/',(req,res,next)=>{
   	console.log('如果有用户访问 http://127.0.0.1 就会先触发这个中间件（函数）--1')
   	next()
   })
   app.use('/',(req,res,next)=>{
   	console.log('如果有用户访问 http://127.0.0.1 就会再触发这个中间件（函数）--2')
   	next()
   })
   ```

9. 配置中间件

   ```js
   // 配置跨域中间件
   app.use(cors())
   // 配置post请求参数解析中间件
   app.use(express.urlencoded({extended:false}))
   // 配置json格式参数解析中间件
   app.use(express.json())
   ```

10. 错误级中间件

    ```js
    app.use((err,req,res,next)=>{
    	console.log(err) // 打印错误信息
        res.send('服务器出现错误，稍后再试')
    })
    ```

    



#### 8.6 mysql

##### 概念

mysql是数据库的一种，用于管理数据

sql语句是用于管理数据的一种语言

##### 使用

- 查询语句

  ```
  select * from 表名
  select 列名 from 表名
  ```

- 插入语句

  ```
  insert into 表名 (列名1,列名2,...) values (值1,值2,...)
  ```

- 更新语句

  ```
  update 表名 set 列名 = 新值 where 限定条件
  ```

- 删除语句

  ```
  delete from 表名 where 限定条件
  ```

  

#### 8.7 身份认证

##### 概念

- cookie 

  ```
  只需要检验是否存在令牌-不安全
  ```

- session 

  ```
  所有登录信息都存放在服务器的session清单中，每次访问都验证是否存在令牌的和session
  ```

- JWT(token)

  ```
  所有登录信息都加密处理，每次访问都解密对比
  ```

  

### 09 node阶段中es6补充（重要）

#### 9.1 es6模块化

##### 概念

es6的模块化是浏览器和服务器端都推荐使用的

##### 使用

1. 默认导入

   ```
   // m1.js
   export default {
   	a:1,
   	b:2
   }
   ```

2. 默认导出

   ```
   import m from ‘./m1.js’
   m.a
   m.b
   ```

3. 按需导出

   ```
   // m2.js
   export let a = 1;
   export let b = 2;
   ```

4. 按需导入

   ```
   import {a,b} from './m2.js'
   a
   b
   ```

   直接导入、单纯执行模块中的代码

   ```
   import './m3.js'
   ```

   

#### 9.2 promise

##### 概念

解决异步回调嵌套问题的技术(promise 原生)

##### 使用

```js
new Promise(function (resolve, reject) {
    // 异步请求 
    resolve()
})
.then(// 异步请求)
.then(// 异步请求)
.then(// 异步请求)
```



#### 9.3 async/await

##### 概念

解决异步回调嵌套问题的**终极**技术(async/await 原生、promise的内部写法太过复杂)

##### 使用

```js
const run = async () => {
    let r1 = await fn1()
    let r2 = await fn2()
    let r3 = await fn3()
}
run()
```

